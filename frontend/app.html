<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JIRA Date Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #2c2c2c;
            color: #fff;
            padding: 20px 0;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid #444;
            margin-bottom: 20px;
        }

        .sidebar-header h1 {
            font-size: 1.2em;
            font-weight: 600;
        }

        .nav-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background: #3a3a3a;
        }

        .nav-item.active {
            background: #3a3a3a;
            border-left-color: #666;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Top Bar */
        .top-bar {
            background: #fff;
            padding: 15px 30px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .breadcrumbs {
            color: #666;
            font-size: 0.9em;
        }

        .breadcrumbs a {
            color: #666;
            text-decoration: none;
        }

        .breadcrumbs a:hover {
            text-decoration: underline;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
        }

        .status-dot.connected {
            background: #4caf50;
        }

        .status-dot.disconnected {
            background: #f44336;
        }

        /* Content Area */
        .content-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            color: #666;
            font-size: 0.95em;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #333;
        }

        .tab.active {
            color: #333;
            border-bottom-color: #333;
            font-weight: 600;
        }

        /* Forms */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em;
            font-family: inherit;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        /* JQL Autocomplete */
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .autocomplete-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background: #f0f0f0;
        }

        .autocomplete-suggestion .keyword {
            font-weight: 600;
            color: #333;
        }

        .autocomplete-suggestion .description {
            font-size: 0.85em;
            color: #666;
            margin-left: 8px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #333;
            color: #fff;
        }

        .btn-primary:hover:not(:disabled) {
            background: #222;
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Table */
        .table-container {
            background: #fff;
            border-radius: 4px;
            overflow-x: auto;
            overflow-y: visible;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            max-width: 100%;
        }
        
        .table-container table {
            min-width: 100%;
            table-layout: auto;
        }
        
        .table-container td {
            white-space: normal;
            word-wrap: break-word;
            word-break: break-word;
            max-width: 300px;
        }

        /* Story Points Breakdown */
        .story-points-breakdown {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
            white-space: pre-line;
        }

        .story-points-breakdown a {
            color: #0066cc;
            text-decoration: underline;
        }

        .story-points-breakdown a:hover {
            color: #004499;
            text-decoration: underline;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #f8f8f8;
        }

        th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #ddd;
            cursor: pointer;
            user-select: none;
            white-space: normal;
            word-wrap: break-word;
            word-break: break-word;
            max-width: 200px;
            vertical-align: top;
        }

        th:hover {
            background: #f0f0f0;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }

        tr:hover {
            background: #f8f8f8;
        }

        /* Date Display */
        .date-cell {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .date-current {
            font-weight: 600;
            color: #333;
        }

        .date-history {
            font-size: 0.85em;
            color: #999;
            display: block;
            margin-top: 4px;
            line-height: 1.6;
        }

        .date-history span {
            text-decoration: line-through;
            display: block;
            margin-bottom: 2px;
        }

        .week-slip {
            font-weight: 700;
            font-size: 1.1em;
            padding: 4px 8px;
            border-radius: 3px;
            display: inline-block;
        }

        .week-slip.red {
            color: #d32f2f;
            background: #ffebee;
        }

        .week-slip.green {
            color: #388e3c;
            background: #e8f5e9;
        }

        .week-slip.gray {
            color: #666;
            background: #f5f5f5;
        }

        /* Date Metrics (Change Count + Week Slip) */
        .date-metrics {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 6px;
        }

        .change-count {
            font-size: 0.85em;
            color: #666;
            font-weight: 500;
        }

        /* Risk Indicator Color Highlighting */
        .risk-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: 500;
            text-align: center;
            min-width: 60px;
        }

        .risk-indicator.red {
            background-color: #fee2e2; /* Soft red background */
            color: #991b1b; /* Dark red text */
            border: 1px solid #fecaca; /* Lighter red border */
        }

        .risk-indicator.yellow {
            background-color: #fef3c7; /* Soft yellow background */
            color: #92400e; /* Dark yellow/brown text */
            border: 1px solid #fde68a; /* Lighter yellow border */
        }

        .risk-indicator.green {
            background-color: #d1fae5; /* Soft green background */
            color: #065f46; /* Dark green text */
            border: 1px solid #a7f3d0; /* Lighter green border */
        }

        /* Alerts */
        .alert {
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .alert-error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #d32f2f;
        }

        .alert-success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }

        .alert-info {
            background: #e3f2fd;
            color: #1565c0;
            border-left: 4px solid #2196f3;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #333;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Hidden */
        .hidden {
            display: none;
        }

        /* Page Styles */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Sidebar Navigation -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>üìÖ JIRA Date Tracker</h1>
        </div>
        <nav>
            <div class="nav-item active" data-page="home">
                üè† Home
            </div>
            <div class="nav-item" data-page="query">
                üîç Query Builder
            </div>
            <div class="nav-item" data-page="config">
                ‚öôÔ∏è Configuration
            </div>
            <div class="nav-item" data-page="reports">
                üìä Reports
            </div>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="breadcrumbs" id="breadcrumbs">
                Home
            </div>
            <div class="connection-status" id="connectionStatus">
                <div class="status-dot" id="statusDot" class="disconnected"></div>
                <span id="statusText">Checking connection...</span>
            </div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <!-- Home Page -->
            <div class="page active" id="page-home">
                <h2>Welcome to JIRA Date Tracker</h2>
                <p style="margin: 20px 0; color: #666;">
                    Track JIRA project date movements and calculate calendar week slips.
                </p>
                <div style="margin-top: 30px;">
                    <button class="btn btn-primary" onclick="navigateTo('query')">
                        Start Query Builder ‚Üí
                    </button>
                </div>
            </div>

            <!-- Query Builder Page -->
            <div class="page" id="page-query">
                <h2>Query Builder</h2>
                
                <!-- Project and FixVersion Selectors -->
                <div style="background: #f8f8f8; padding: 20px; border-radius: 4px; margin-top: 20px; margin-bottom: 20px;">
                    <h3 style="margin-top: 0; margin-bottom: 15px; font-size: 1.1em;">Quick Select (Automatic JQL)</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group" style="margin: 0;">
                            <label for="projectSelect">Project</label>
                            <select id="projectSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="">-- Select Project --</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label for="versionSelect">Fix Version</label>
                            <select id="versionSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px;" disabled>
                                <option value="">-- Select Project First --</option>
                            </select>
                        </div>
                    </div>
                    <div style="font-size: 0.85em; color: #666; margin-top: 10px;">
                        üí° Select a project and fixVersion to automatically generate JQL query
                    </div>
                </div>

                <div style="text-align: center; margin: 15px 0; color: #666; font-weight: 500;">OR</div>

                <div class="form-group" style="margin-top: 20px;">
                    <label for="jqlInput">JQL Query (Manual)</label>
                    <div style="position: relative;">
                        <textarea 
                            id="jqlInput" 
                            placeholder='Enter JQL query (e.g., project = PROJ AND status = "In Progress") or filter (e.g., filter=12345 or filter="Filter Name")'
                            autocomplete="off"
                            spellcheck="false"
                        ></textarea>
                        <div id="jqlAutocomplete" class="autocomplete-suggestions" style="display: none;"></div>
                    </div>
                    <div style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        üí° Tip: Use <code>filter="Filter Name"</code> for named filters, or <code>filter=12345</code> for numeric filter IDs
                    </div>
                </div>

                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn btn-primary" onclick="executeQuery()" id="queryButton">
                        Execute Query
                    </button>
                    <button class="btn" onclick="clearResults()" style="background: #f5f5f5;">
                        Clear
                    </button>
                </div>

                <div id="queryResults" class="hidden">
                    <div class="tabs">
                        <button class="tab active" data-tab="table">Table View</button>
                        <button class="tab" data-tab="raw">Raw Data</button>
                    </div>

                    <div id="tab-table" class="tab-content">
                        <!-- Pagination Controls -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: #f8f8f8; border-radius: 4px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label for="pageSize">Records per page:</label>
                                <select id="pageSize" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 3px;">
                                    <option value="10">10</option>
                                    <option value="25" selected>25</option>
                                    <option value="50">50</option>
                                    <option value="100">100</option>
                                    <option value="200">200</option>
                                </select>
                            </div>
                            <div id="paginationInfo" style="color: #666; font-size: 0.9em;"></div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div id="paginationControls" style="display: flex; gap: 5px;"></div>
                                <div style="margin-left: 15px; padding-left: 15px; border-left: 1px solid #ddd;">
                                    <span style="color: #666; font-size: 0.9em; margin-right: 8px;">Export:</span>
                                    <a href="#" id="exportPDF" style="display: none; color: #0066cc; text-decoration: none; font-size: 0.9em; margin-right: 10px; padding: 4px 8px; border-radius: 3px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='transparent'">PDF</a>
                                    <a href="#" id="exportCSV" style="color: #0066cc; text-decoration: none; font-size: 0.9em; margin-right: 10px; padding: 4px 8px; border-radius: 3px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='transparent'">CSV</a>
                                    <a href="#" id="exportEmail" style="color: #0066cc; text-decoration: none; font-size: 0.9em; padding: 4px 8px; border-radius: 3px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='transparent'">Email</a>
                                </div>
                            </div>
                        </div>
                        <div class="table-container">
                            <table id="resultsTable">
                                <thead id="tableHead"></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <div id="tab-raw" class="tab-content hidden">
                        <pre id="rawData" style="background: #f5f5f5; padding: 20px; border-radius: 4px; overflow-x: auto;"></pre>
                    </div>
                </div>

                <div id="queryLoading" class="loading hidden">
                    <div class="spinner"></div>
                    <p>Executing query and fetching date history...</p>
                </div>

                <div id="queryError" class="alert alert-error hidden"></div>
            </div>

            <!-- Configuration Page -->
            <div class="page" id="page-config">
                <h2>Configuration</h2>
                <p style="margin: 20px 0; color: #666;">
                    Configuration is loaded from <code>config/fields.json</code>
                </p>
                <div id="configDisplay" style="background: #f5f5f5; padding: 20px; border-radius: 4px; margin-top: 20px;">
                    <p>Loading configuration...</p>
                </div>
            </div>

            <!-- Reports Page -->
            <div class="page" id="page-reports">
                <h2>Reports</h2>
                <p style="margin: 20px 0; color: #666;">
                    Reports and analytics will be available here.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Backend API URL - use same origin if possible, otherwise default to localhost
        const BACKEND_API_URL = window.BACKEND_API_URL || 
            (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') 
                ? 'http://localhost:8473' 
                : `${window.location.protocol}//${window.location.hostname}:8473`;

        // Navigation
        function navigateTo(page) {
            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.page === page) {
                    item.classList.add('active');
                }
            });

            // Update active page
            document.querySelectorAll('.page').forEach(p => {
                p.classList.remove('active');
            });
            document.getElementById(`page-${page}`).classList.add('active');

            // Update breadcrumbs
            updateBreadcrumbs(page);

            // Load page-specific data
            if (page === 'config') {
                loadConfiguration();
            } else if (page === 'query') {
                loadProjects();
            }
        }

        function updateBreadcrumbs(page) {
            const breadcrumbMap = {
                'home': 'Home',
                'query': 'Home > Query Builder',
                'config': 'Home > Configuration',
                'reports': 'Home > Reports'
            };
            document.getElementById('breadcrumbs').textContent = breadcrumbMap[page] || 'Home';
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                
                // Update active tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');

                // Show/hide tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.add('hidden');
                });
                document.getElementById(`tab-${tabName}`).classList.remove('hidden');
            });
        });

        // Sidebar navigation
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                navigateTo(this.dataset.page);
            });
        });

        // Connection status check
        async function checkConnection() {
            try {
                const response = await fetch(`${BACKEND_API_URL}/health`, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache'
                });
                if (response.ok) {
                    const data = await response.json();
                    updateConnectionStatus(true, 'Backend connected');
                } else {
                    updateConnectionStatus(false, 'Backend error');
                }
            } catch (error) {
                // Check if it's a network error vs CORS
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    updateConnectionStatus(false, 'Cannot reach backend');
                } else {
                    updateConnectionStatus(false, 'Connection error');
                }
            }
        }

        function updateConnectionStatus(connected, message = null) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            if (connected) {
                dot.classList.add('connected');
                dot.classList.remove('disconnected');
                text.textContent = message || 'Connected';
            } else {
                dot.classList.add('disconnected');
                dot.classList.remove('connected');
                text.textContent = message || 'Disconnected';
            }
        }

        // JQL Autocomplete
        const JQL_KEYWORDS = [
            { keyword: 'project', description: 'Filter by project' },
            { keyword: 'status', description: 'Filter by status' },
            { keyword: 'assignee', description: 'Filter by assignee' },
            { keyword: 'type', description: 'Filter by issue type' },
            { keyword: 'fixVersion', description: 'Filter by fix version' },
            { keyword: 'priority', description: 'Filter by priority' },
            { keyword: 'created', description: 'Filter by creation date' },
            { keyword: 'updated', description: 'Filter by update date' },
            { keyword: 'resolved', description: 'Filter by resolution date' },
            { keyword: 'filter', description: 'Use saved filter (filter=12345 or filter="Name")' },
            { keyword: 'AND', description: 'Logical AND operator' },
            { keyword: 'OR', description: 'Logical OR operator' },
            { keyword: 'NOT', description: 'Logical NOT operator' },
            { keyword: 'IN', description: 'IN operator (e.g., status IN ("Open", "In Progress"))' },
            { keyword: 'ORDER BY', description: 'Sort results (e.g., ORDER BY created DESC)' },
            { keyword: '=', description: 'Equals operator' },
            { keyword: '!=', description: 'Not equals operator' },
            { keyword: '~', description: 'Contains operator (text search)' },
            { keyword: 'IS', description: 'IS operator (e.g., status IS EMPTY)' },
            { keyword: 'IS NOT', description: 'IS NOT operator' },
        ];

        let autocompleteSelectedIndex = -1;
        let currentSuggestions = [];

        function setupJQLAutocomplete() {
            const jqlInput = document.getElementById('jqlInput');
            const autocomplete = document.getElementById('jqlAutocomplete');

            jqlInput.addEventListener('input', function(e) {
                const value = e.target.value;
                const cursorPos = e.target.selectionStart;
                
                // Get the word being typed - improved to handle special characters
                const textBeforeCursor = value.substring(0, cursorPos);
                
                // Try multiple patterns to find the current word
                let currentWord = '';
                let wordStart = cursorPos;
                
                // Pattern 1: Standard word characters (letters, digits, underscore)
                let match = textBeforeCursor.match(/([\w-]+)$/);
                if (match) {
                    currentWord = match[1];
                    wordStart = cursorPos - currentWord.length;
                } else {
                    // Pattern 2: After filter=, match filter name (can contain dashes, underscores)
                    match = textBeforeCursor.match(/filter\s*=\s*([\w-]+)$/i);
                    if (match) {
                        currentWord = match[1];
                        wordStart = cursorPos - currentWord.length;
                    } else {
                        // Pattern 3: Inside quotes after filter=", match quoted filter name
                        match = textBeforeCursor.match(/filter\s*=\s*"([^"]*)$/i);
                        if (match) {
                            currentWord = match[1];
                            wordStart = cursorPos - currentWord.length;
                        } else {
                            // Pattern 4: After operators like =, !=, ~, IN, etc.
                            match = textBeforeCursor.match(/[=!~<>]+\s*([\w-]+)$/i);
                            if (match) {
                                currentWord = match[1];
                                wordStart = cursorPos - currentWord.length;
                            }
                        }
                    }
                }
                
                // Show autocomplete if we have a word to match
                if (currentWord.length >= 1) {
                    // Find matching keywords (case-insensitive)
                    const suggestions = JQL_KEYWORDS.filter(item => 
                        item.keyword.toLowerCase().startsWith(currentWord.toLowerCase())
                    ).slice(0, 5); // Limit to 5 suggestions
                    
                    if (suggestions.length > 0) {
                        currentSuggestions = suggestions;
                        autocompleteSelectedIndex = -1;
                        showAutocomplete(suggestions, currentWord, cursorPos);
                    } else {
                        hideAutocomplete();
                    }
                } else {
                    hideAutocomplete();
                }
            });

            jqlInput.addEventListener('keydown', function(e) {
                if (autocomplete.style.display === 'none') return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, currentSuggestions.length - 1);
                    updateAutocompleteSelection();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, -1);
                    updateAutocompleteSelection();
                } else if (e.key === 'Enter' && autocompleteSelectedIndex >= 0) {
                    e.preventDefault();
                    insertSuggestion(currentSuggestions[autocompleteSelectedIndex].keyword);
                } else if (e.key === 'Escape') {
                    hideAutocomplete();
                }
            });

            // Hide autocomplete when clicking outside
            document.addEventListener('click', function(e) {
                if (!jqlInput.contains(e.target) && !autocomplete.contains(e.target)) {
                    hideAutocomplete();
                }
            });
        }

        function showAutocomplete(suggestions, currentWord, cursorPos) {
            const autocomplete = document.getElementById('jqlAutocomplete');
            autocomplete.innerHTML = suggestions.map((item, index) => 
                `<div class="autocomplete-suggestion ${index === 0 ? 'selected' : ''}" data-index="${index}">
                    <span class="keyword">${item.keyword}</span>
                    <span class="description">${item.description}</span>
                </div>`
            ).join('');
            
            autocomplete.style.display = 'block';
            
            // Add click handlers
            autocomplete.querySelectorAll('.autocomplete-suggestion').forEach((el, index) => {
                el.addEventListener('click', () => {
                    insertSuggestion(suggestions[index].keyword);
                });
            });
        }

        function updateAutocompleteSelection() {
            const suggestions = autocomplete.querySelectorAll('.autocomplete-suggestion');
            suggestions.forEach((el, index) => {
                if (index === autocompleteSelectedIndex) {
                    el.classList.add('selected');
                    el.scrollIntoView({ block: 'nearest' });
                } else {
                    el.classList.remove('selected');
                }
            });
        }

        function insertSuggestion(keyword) {
            const jqlInput = document.getElementById('jqlInput');
            const value = jqlInput.value;
            const cursorPos = jqlInput.selectionStart;
            
            const textBeforeCursor = value.substring(0, cursorPos);
            
            // Use the same pattern matching as in the input handler
            let match = textBeforeCursor.match(/([\w-]+)$/);
            if (!match) {
                match = textBeforeCursor.match(/filter\s*=\s*([\w-]+)$/i);
            }
            if (!match) {
                match = textBeforeCursor.match(/filter\s*=\s*"([^"]*)$/i);
            }
            if (!match) {
                match = textBeforeCursor.match(/[=!~<>]+\s*([\w-]+)$/i);
            }
            
            if (match) {
                const startPos = cursorPos - match[1].length;
                const newValue = value.substring(0, startPos) + keyword + value.substring(cursorPos);
                jqlInput.value = newValue;
                jqlInput.setSelectionRange(startPos + keyword.length, startPos + keyword.length);
            }
            
            hideAutocomplete();
            jqlInput.focus();
        }

        function hideAutocomplete() {
            const autocomplete = document.getElementById('jqlAutocomplete');
            autocomplete.style.display = 'none';
            autocompleteSelectedIndex = -1;
            currentSuggestions = [];
        }

        // Query execution
        async function executeQuery() {
            const jql = document.getElementById('jqlInput').value.trim();
            const button = document.getElementById('queryButton');
            const loading = document.getElementById('queryLoading');
            const results = document.getElementById('queryResults');
            const error = document.getElementById('queryError');

            // Hide autocomplete when executing
            hideAutocomplete();

            if (!jql) {
                error.textContent = 'Please enter a JQL query';
                error.classList.remove('hidden');
                return;
            }

            // Reset UI
            button.disabled = true;
            loading.classList.remove('hidden');
            results.classList.add('hidden');
            error.classList.add('hidden');

            try {
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 minute timeout
                
                const response = await fetch(`${BACKEND_API_URL}/api/query`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        jql: jql,
                        max_results: 100,
                        include_history: true
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                // Check if response is OK
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText.substring(0, 200)}`);
                }

                // Check content type
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    throw new Error(`Expected JSON but got ${contentType}. Response: ${text.substring(0, 200)}`);
                }

                // Parse JSON
                const responseText = await response.text();
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    // Provide more helpful error message
                    const preview = responseText.substring(0, 300);
                    throw new Error(`Invalid JSON response from server. ${e.message}. Response preview: ${preview}`);
                }

                if (data.success) {
                    displayResults(data);
                    results.classList.remove('hidden');
                } else {
                    error.textContent = data.error || 'Query execution failed';
                    error.classList.remove('hidden');
                }
            } catch (err) {
                // Clear timeout if it exists
                if (typeof timeoutId !== 'undefined') {
                    clearTimeout(timeoutId);
                }
                
                let errorMessage = err.message;
                if (err.name === 'AbortError' || err.message.includes('aborted')) {
                    errorMessage = 'Request timed out after 2 minutes. The query may be processing too many issues. Try reducing max_results or disabling history fetching.';
                } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
                    errorMessage = `Cannot connect to backend server. Make sure the backend server is running at ${BACKEND_API_URL}`;
                }
                error.textContent = `Error: ${errorMessage}`;
                error.classList.remove('hidden');
                results.classList.add('hidden');
            } finally {
                // Always re-enable button and hide loading, even on timeout
                button.disabled = false;
                loading.classList.add('hidden');
            }
        }

        // Pagination state
        let currentPage = 1;
        let pageSize = 25;
        let allIssues = [];

        function displayResults(data) {
            allIssues = data.issues || [];
            window.fieldMetadata = data.field_metadata || {};
            window.displayColumns = data.display_columns || [];

            // Display raw data
            document.getElementById('rawData').textContent = JSON.stringify(data, null, 2);

            // Reset pagination
            currentPage = 1;
            pageSize = parseInt(document.getElementById('pageSize').value) || 25;

            // Build table
            if (allIssues.length === 0) {
                document.getElementById('tableBody').innerHTML = 
                    '<tr><td colspan="100%" style="text-align: center; padding: 40px; color: #666;">No issues found</td></tr>';
                document.getElementById('paginationInfo').textContent = '';
                document.getElementById('paginationControls').innerHTML = '';
                return;
            }

            // Render table with pagination
            renderTablePage(allIssues, window.fieldMetadata);
        }

        function renderTablePage(issues, fieldMetadata) {
            // Calculate pagination
            const totalPagesCount = Math.ceil(issues.length / pageSize);
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, issues.length);
            const pageIssues = issues.slice(startIndex, endIndex);

            // Use display_columns from config if available, otherwise fallback to all fields
            let tableColumns = [];
            if (allIssues.length > 0) {
                const firstIssue = allIssues[0];
                const fields = firstIssue.fields || {};
                // Check if we stored display_columns in the data
                if (window.displayColumns && Array.isArray(window.displayColumns) && window.displayColumns.length > 0) {
                    tableColumns = window.displayColumns;
                } else {
                    tableColumns = Object.keys(fields).filter(key => 
                        !key.includes('_history') && 
                        !key.includes('_week_slip') && 
                        !key.includes('_formatted') &&
                        key !== 'issuetype' &&
                        key !== 'project'
                    );
                }
            }

            // Build header
            const thead = document.getElementById('tableHead');
            thead.innerHTML = '<tr>' + 
                tableColumns.map(col => {
                    const fieldName = fieldMetadata[col]?.name || col;
                    return `<th>${fieldName}</th>`;
                }).join('') + 
            '</tr>';

            // Build body
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = pageIssues.map(issue => {
                const fields = issue.fields || {};
                
                return '<tr>' + 
                    tableColumns.map(col => {
                        // Get the actual field value (handle special fields like 'key' at issue level)
                        let value;
                        if (col === 'key') {
                            value = issue.key || issue.id;
                        } else {
                            value = fields[col];
                        }
                        
                        let display = '';

                        // Check if this is a date field with history
                        if (fields[`${col}_formatted`]) {
                            const current = fields[`${col}_formatted`];
                            const history = fields[`${col}_history`] || [];
                            const weekSlip = fields[`${col}_week_slip`];
                            const changeCount = fields[`${col}_change_count`] || 0;

                            display = '<div class="date-cell">';
                            display += `<div class="date-current">${current}</div>`;
                            
                            if (history.length > 0) {
                                display += '<div class="date-history">' +
                                    history.map(d => `<span>${d}</span>`).join('') +
                                '</div>';
                            }

                            // Display change count and date difference
                            if (changeCount > 0 || weekSlip) {
                                display += '<div class="date-metrics">';
                                
                                // Change count
                                if (changeCount > 0) {
                                    display += `<span class="change-count">Changed ${changeCount} time${changeCount !== 1 ? 's' : ''}</span>`;
                                }
                                
                                // Date difference (from first to current)
                                if (weekSlip && weekSlip.display && weekSlip.display !== 'N/A') {
                                    display += `<span class="week-slip ${weekSlip.color}">${weekSlip.display}</span>`;
                                }
                                
                                display += '</div>';
                            }
                            
                            display += '</div>';
                        } else if (value !== null && value !== undefined) {
                            // Check if this is the Risk Indicator field (customfield_23560)
                            if (col === 'customfield_23560') {
                                // Extract value from object if needed (JIRA custom fields can be objects)
                                let riskText = '';
                                
                                // Handle different value types
                                if (value === null || value === undefined) {
                                    riskText = '';
                                } else if (Array.isArray(value)) {
                                    // Handle array values (take first element)
                                    if (value.length > 0) {
                                        const firstItem = value[0];
                                        if (typeof firstItem === 'object' && firstItem !== null) {
                                            riskText = firstItem.value || firstItem.name || firstItem.displayName || firstItem.id || String(firstItem);
                                        } else {
                                            riskText = String(firstItem);
                                        }
                                    } else {
                                        riskText = '';
                                    }
                                } else if (typeof value === 'object') {
                                    // Handle object values - check multiple possible properties
                                    // JIRA custom fields can have different structures
                                    riskText = value.value || 
                                              value.name || 
                                              value.displayName || 
                                              value.label ||
                                              value.id ||
                                              (value.toString && value.toString() !== '[object Object]' ? value.toString() : '');
                                    
                                    // If still empty or [object Object], try to find any string property
                                    if (!riskText || riskText === '[object Object]' || riskText === '{}') {
                                        for (const key in value) {
                                            if (value.hasOwnProperty(key)) {
                                                const propValue = value[key];
                                                if (typeof propValue === 'string' && propValue.trim()) {
                                                    riskText = propValue;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Last resort: try JSON.stringify but extract meaningful content
                                    if (!riskText || riskText === '[object Object]' || riskText === '{}') {
                                        try {
                                            const jsonStr = JSON.stringify(value);
                                            // Try to extract value from JSON if it's a simple object
                                            const match = jsonStr.match(/"value"\s*:\s*"([^"]+)"/) ||
                                                         jsonStr.match(/"name"\s*:\s*"([^"]+)"/) ||
                                                         jsonStr.match(/"displayName"\s*:\s*"([^"]+)"/);
                                            riskText = match ? match[1] : '';
                                        } catch (e) {
                                            riskText = '';
                                        }
                                    }
                                } else {
                                    // Primitive value (string, number, boolean)
                                    riskText = String(value);
                                }
                                
                                // Clean up the text
                                riskText = riskText.trim();
                                
                                // Only proceed if we have valid text
                                if (riskText && riskText !== '[object Object]' && riskText !== '{}') {
                                    const riskValue = riskText.toLowerCase();
                                    let riskClass = '';
                                    
                                    if (riskValue === 'red' || riskValue.includes('red')) {
                                        riskClass = 'red';
                                    } else if (riskValue === 'yellow' || riskValue.includes('yellow')) {
                                        riskClass = 'yellow';
                                    } else if (riskValue === 'green' || riskValue.includes('green')) {
                                        riskClass = 'green';
                                    }
                                    
                                    if (riskClass) {
                                        display = `<span class="risk-indicator ${riskClass}">${riskText}</span>`;
                                    } else {
                                        display = riskText;
                                    }
                                } else {
                                    // If we couldn't extract a valid value, show empty or fallback
                                    display = '-';
                                }
                            } else {
                                // Check if this field should show AI summary
                                const showAiSummary = fields[`${col}_show_ai_summary`] !== false; // Default to true
                                const summary = fields[`${col}_summary`];
                                const original = fields[`${col}_original`];
                                
                                // Debug logging (remove in production)
                                if (col === 'customfield_23073') {
                                    console.log(`Status Update field - value:`, value, `summary:`, summary, `showAiSummary:`, showAiSummary, `fields:`, Object.keys(fields).filter(k => k.includes('23073')));
                                }
                                
                                if (summary && summary.trim() && showAiSummary) {
                                    // Show AI summary with expandable full text
                                    display = `<div class="exec-summary">
                                        <div class="summary-text">${summary}</div>
                                        <div class="summary-original" style="font-size: 0.85em; color: #999; margin-top: 4px;">
                                            <details><summary>View full text</summary>${original || value}</details>
                                        </div>
                                    </div>`;
                                } else if (typeof value === 'object') {
                                    // Handle object values (like assignee, status, fixVersions)
                                    if (Array.isArray(value)) {
                                        // Handle arrays (like fixVersions)
                                        display = value.map(v => v.name || v.displayName || v.value || String(v)).join(', ');
                                    } else {
                                        display = value.displayName || value.name || value.value || JSON.stringify(value);
                                    }
                                } else {
                                    // Handle story points breakdown with line breaks and HTML
                                    if (col === 'story_points_breakdown' && value) {
                                        // Value already contains HTML (hyperlinks and bold tags)
                                        // Convert newlines to <br> tags and wrap in styled div
                                        const formattedValue = String(value).replace(/\n/g, '<br>');
                                        display = `<div class="story-points-breakdown">${formattedValue}</div>`;
                                    } else {
                                        display = String(value);
                                    }
                                }
                            }
                        }

                        return `<td>${display || '-'}</td>`;
                    }).join('') + 
                '</tr>';
            }).join('');

            // Update pagination info
            document.getElementById('paginationInfo').textContent = 
                `Showing ${startIndex + 1}-${endIndex} of ${issues.length} issues`;

            // Build pagination controls
            const paginationControls = document.getElementById('paginationControls');
            let paginationHTML = '';
            
            // Previous button
            paginationHTML += `<button class="btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})" style="padding: 5px 10px; font-size: 0.9em;">Previous</button>`;
            
            // Page numbers
            const maxPagesToShow = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
            let endPage = Math.min(totalPagesCount, startPage + maxPagesToShow - 1);
            if (endPage - startPage < maxPagesToShow - 1) {
                startPage = Math.max(1, endPage - maxPagesToShow + 1);
            }
            
            if (startPage > 1) {
                paginationHTML += `<button class="btn" onclick="changePage(1)" style="padding: 5px 10px; font-size: 0.9em;">1</button>`;
                if (startPage > 2) {
                    paginationHTML += `<span style="padding: 5px;">...</span>`;
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                paginationHTML += `<button class="btn ${i === currentPage ? 'btn-primary' : ''}" onclick="changePage(${i})" style="padding: 5px 10px; font-size: 0.9em;">${i}</button>`;
            }
            
            if (endPage < totalPagesCount) {
                if (endPage < totalPagesCount - 1) {
                    paginationHTML += `<span style="padding: 5px;">...</span>`;
                }
                paginationHTML += `<button class="btn" onclick="changePage(${totalPagesCount})" style="padding: 5px 10px; font-size: 0.9em;">${totalPagesCount}</button>`;
            }
            
            // Next button
            paginationHTML += `<button class="btn" ${currentPage === totalPagesCount ? 'disabled' : ''} onclick="changePage(${currentPage + 1})" style="padding: 5px 10px; font-size: 0.9em;">Next</button>`;
            
            paginationControls.innerHTML = paginationHTML;
        }

        function changePage(page) {
            const totalPages = Math.ceil(allIssues.length / pageSize);
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            // Get field metadata - we need to store it globally
            if (allIssues.length > 0) {
                renderTablePage(allIssues, window.fieldMetadata || {});
            }
            // Scroll to top of table
            document.querySelector('.table-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function clearResults() {
            document.getElementById('queryResults').classList.add('hidden');
            document.getElementById('jqlInput').value = '';
            document.getElementById('projectSelect').value = '';
            document.getElementById('versionSelect').value = '';
            document.getElementById('versionSelect').disabled = true;
            document.getElementById('versionSelect').innerHTML = '<option value="">-- Select Project First --</option>';
        }

        // Load projects with fixVersions
        async function loadProjects() {
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/projects`);
                const data = await response.json();
                
                const projectSelect = document.getElementById('projectSelect');
                if (data.success && data.projects) {
                    projectSelect.innerHTML = '<option value="">-- Select Project --</option>';
                    data.projects.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project.key;
                        option.textContent = `${project.name} (${project.key})`;
                        projectSelect.appendChild(option);
                    });
                } else {
                    projectSelect.innerHTML = '<option value="">Error loading projects</option>';
                }
            } catch (error) {
                console.error('Error loading projects:', error);
                document.getElementById('projectSelect').innerHTML = '<option value="">Error loading projects</option>';
            }
        }

        // Load versions for selected project
        async function loadVersions(projectKey) {
            const versionSelect = document.getElementById('versionSelect');
            
            if (!projectKey) {
                versionSelect.disabled = true;
                versionSelect.innerHTML = '<option value="">-- Select Project First --</option>';
                return;
            }
            
            versionSelect.disabled = true;
            versionSelect.innerHTML = '<option value="">Loading versions...</option>';
            
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/projects/${projectKey}/versions`);
                const data = await response.json();
                
                if (data.success && data.versions) {
                    versionSelect.innerHTML = '<option value="">-- Select Fix Version --</option>';
                    data.versions.forEach(version => {
                        const option = document.createElement('option');
                        option.value = version.name;
                        option.textContent = version.name + (version.archived ? ' (Archived)' : '') + (version.released ? ' (Released)' : '');
                        versionSelect.appendChild(option);
                    });
                    versionSelect.disabled = false;
                } else {
                    versionSelect.innerHTML = '<option value="">No versions found</option>';
                }
            } catch (error) {
                console.error('Error loading versions:', error);
                versionSelect.innerHTML = '<option value="">Error loading versions</option>';
            }
        }

        // Auto-generate JQL from project and version selections
        function generateJQLFromSelection() {
            const projectKey = document.getElementById('projectSelect').value;
            const versionName = document.getElementById('versionSelect').value;
            
            if (projectKey && versionName) {
                // Escape version name if it contains special characters
                const escapedVersion = versionName.includes(' ') || versionName.includes('-') 
                    ? `"${versionName}"` 
                    : versionName;
                const jql = `project = ${projectKey} AND fixVersion = ${escapedVersion}`;
                document.getElementById('jqlInput').value = jql;
            }
        }

        // Load configuration
        async function loadConfiguration() {
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/config`);
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('configDisplay').innerHTML = 
                        '<pre>' + JSON.stringify(data.config, null, 2) + '</pre>';
                } else {
                    document.getElementById('configDisplay').innerHTML = 
                        '<p style="color: #d32f2f;">Error loading configuration: ' + data.error + '</p>';
                }
            } catch (error) {
                document.getElementById('configDisplay').innerHTML = 
                    '<p style="color: #d32f2f;">Error: ' + error.message + '</p>';
            }
        }

        // Export functions
        async function exportData(format) {
            if (!allIssues || allIssues.length === 0) {
                alert('No data to export. Please run a query first.');
                return;
            }

            try {
                const response = await fetch(`${BACKEND_API_URL}/api/export/${format}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        issues: allIssues,
                        field_metadata: window.fieldMetadata || {},
                        display_columns: window.displayColumns || []
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `Export failed: ${response.statusText}`);
                }

                // Get filename from Content-Disposition header or use default
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = `jira_export.${format}`;
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="?(.+)"?/i);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }

                // Download the file
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting data: ' + error.message);
            }
        }

        // Email export function
        async function exportEmail() {
            if (!allIssues || allIssues.length === 0) {
                alert('No data to export. Please run a query first.');
                return;
            }

            // Prompt for email addresses
            const emailInput = prompt('Enter email addresses (comma-separated):');
            if (!emailInput || !emailInput.trim()) {
                return; // User cancelled or entered nothing
            }

            // Validate email addresses
            const emails = emailInput.split(',').map(e => e.trim()).filter(e => e);
            if (emails.length === 0) {
                alert('Please enter at least one valid email address.');
                return;
            }

            // Basic email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            const invalidEmails = emails.filter(e => !emailRegex.test(e));
            if (invalidEmails.length > 0) {
                alert('Invalid email addresses: ' + invalidEmails.join(', '));
                return;
            }

            try {
                const response = await fetch(`${BACKEND_API_URL}/api/export/email`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        issues: allIssues,
                        field_metadata: window.fieldMetadata || {},
                        display_columns: window.displayColumns || [],
                        recipients: emails
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `Email export failed: ${response.statusText}`);
                }

                const result = await response.json();
                alert(`Email sent successfully to: ${emails.join(', ')}`);
            } catch (error) {
                console.error('Email export error:', error);
                alert('Error sending email: ' + error.message);
            }
        }

        // Handle page size change and setup project/version selectors
        document.addEventListener('DOMContentLoaded', function() {
            // Setup project selector
            const projectSelect = document.getElementById('projectSelect');
            if (projectSelect) {
                projectSelect.addEventListener('change', function() {
                    const projectKey = this.value;
                    loadVersions(projectKey);
                    generateJQLFromSelection();
                });
            }

            // Setup version selector
            const versionSelect = document.getElementById('versionSelect');
            if (versionSelect) {
                versionSelect.addEventListener('change', function() {
                    generateJQLFromSelection();
                });
            }

            // Load projects on page load
            loadProjects();

            const pageSizeSelect = document.getElementById('pageSize');
            if (pageSizeSelect) {
                pageSizeSelect.addEventListener('change', function() {
                    pageSize = parseInt(this.value);
                    currentPage = 1;
                    if (allIssues.length > 0) {
                        renderTablePage(allIssues, window.fieldMetadata || {});
                    }
                });
            }

            // Add export button handlers
            document.getElementById('exportPDF')?.addEventListener('click', function(e) {
                e.preventDefault();
                exportData('pdf');
            });
            document.getElementById('exportCSV')?.addEventListener('click', function(e) {
                e.preventDefault();
                exportData('csv');
            });
            document.getElementById('exportEmail')?.addEventListener('click', function(e) {
                e.preventDefault();
                exportEmail();
            });
        });

        // Initialize
        setupJQLAutocomplete();
        // Check connection immediately and then periodically
        checkConnection();
        // Check every 10 seconds for more responsive status
        setInterval(checkConnection, 10000);
        
        // Also check when page becomes visible (user switches back to tab)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                checkConnection();
            }
        });
    </script>
</body>
</html>

